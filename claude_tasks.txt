================================================================================
    LOHIGH: IMPROVEMENT SUGGESTIONS FOR PRACTITIONERS & INDUSTRY
================================================================================

Project Philosophy Alignment:
- Maintain radical simplicity and single-purpose design
- Preserve DJ Sacabambaspis personality and playful tone
- Enhance usability without bloating features
- Keep minimal dependencies and straightforward compilation
- Focus on "do one thing well" with professional polish

================================================================================
CATEGORY 1: AUDIO QUALITY & PROFESSIONAL OUTPUT
================================================================================

1.1 CROSSFADE BETWEEN AUDIO FILES
   Problem: Concatenating WAV files can create audible clicks/pops at transitions
   Solution: Add optional crossfade parameter (--fade=duration)
   Example: ./lohigh input.wav output.wav --fade=1s
   Benefit: Professional-sounding transitions for industry use
   Complexity: LOW - simple linear interpolation between end/start samples

1.2 VOLUME NORMALIZATION
   Problem: Different source files may have vastly different volumes
   Solution: Normalize peak levels to prevent distortion or inaudible mixing
   Options:
     - Auto-normalize (default on)
     - Target level flag: --level=0.8 (80% of max)
   Benefit: Consistent output levels across different source materials
   Complexity: LOW - peak detection + scaling multiplication

1.3 SAMPLE RATE CONVERSION
   Problem: Mixing files with different sample rates causes errors/crashes
   Solution: Auto-detect and resample to match first file's rate
   Options: Quality levels (--resample=fast|good|best)
   Benefit: Accept any WAV file without manual preprocessing
   Complexity: MEDIUM - requires libsamplerate or similar
   Note: Maintains minimalism by auto-handling vs requiring manual tools

1.4 BIT DEPTH HANDLING
   Problem: Mixing 16-bit and 24-bit files loses fidelity
   Solution: Auto-convert to highest bit depth present, preserve quality
   Benefit: Professional audio fidelity preservation
   Complexity: LOW - already handled by libsndfile mostly

================================================================================
CATEGORY 2: FORMAT SUPPORT & COMPATIBILITY
================================================================================

2.1 MULTI-FORMAT INPUT SUPPORT
   Problem: Users often have MP3, FLAC, OGG files, not just WAV
   Solution: Add libavcodec/FFmpeg support for reading common formats
   Formats: MP3, FLAC, OGG, M4A, AAC, OPUS
   Output: Keep WAV output or add --format flag
   Benefit: Works with real-world audio libraries without conversion
   Complexity: MEDIUM - adds FFmpeg dependency
   Alternative: Use libsndfile's FLAC/OGG support (simpler, fewer formats)

2.2 SMART FORMAT DETECTION
   Problem: File extensions might lie or be missing
   Solution: Detect format from file headers/magic bytes
   Benefit: Robust handling of renamed or mis-labeled files
   Complexity: LOW - libsndfile handles this internally

2.3 OUTPUT FORMAT OPTIONS
   Problem: WAV files are large, users may want compressed output
   Solution: Add --output-format flag (wav|flac|ogg)
   Example: ./lohigh a.wav b.wav out.flac --output-format=flac
   Benefit: Smaller files for distribution, streaming
   Complexity: MEDIUM - requires format-specific encoding

================================================================================
CATEGORY 3: USER EXPERIENCE & WORKFLOW
================================================================================

3.1 BATCH PROCESSING MODE
   Problem: Creating lofi mixes for multiple files is repetitive
   Solution: Accept directory or multiple files
   Example: ./lohigh --batch *.wav --output-dir=./mixed/
   Benefit: Process entire music libraries efficiently
   Complexity: LOW - loop over files, same core logic
   Industry Value: HIGH - production workflows need automation

3.2 REVERSE MODE FLAG
   Problem: Sometimes users want beat AFTER content, not before
   Solution: Add --reverse flag to swap file order
   Example: ./lohigh input.wav output.wav --reverse
   Result: output.wav = input.wav + ambient.wav (not ambient + input)
   Benefit: Creative flexibility for different lofi styles
   Complexity: TRIVIAL - swap parameter order in function call

3.3 PROGRESS INDICATORS
   Problem: Large files leave users wondering if tool is working
   Solution: Show progress bar or percentage for >10MB files
   Example: "Mixing... [████████░░] 80% (12.4s elapsed)"
   Benefit: Professional UX, confidence in long operations
   Complexity: LOW - track bytes processed vs total

3.4 PREVIEW MODE
   Problem: Users want to test before processing large files
   Solution: Add --preview=duration flag (process only first N seconds)
   Example: ./lohigh a.wav b.wav test.wav --preview=30s
   Benefit: Quick experimentation without wasting time
   Complexity: LOW - limit read samples to duration * sample_rate

3.5 DRY RUN MODE
   Problem: Users want to verify inputs before processing
   Solution: Add --dry-run flag showing what would be done
   Output: File sizes, durations, sample rates, estimated output size
   Benefit: Validation before committing to large operations
   Complexity: TRIVIAL - read metadata without processing

3.6 VERBOSE/QUIET MODES
   Problem: Different users want different feedback levels
   Solution:
     -v, --verbose: Show detailed processing info
     -q, --quiet: Suppress all output except errors
   Benefit: Scriptability (quiet) and debugging (verbose)
   Complexity: TRIVIAL - conditional print statements

================================================================================
CATEGORY 4: CREATIVE FEATURES (ALIGNED WITH LOFI AESTHETIC)
================================================================================

4.1 MULTI-AMBIENT LIBRARY
   Problem: Single ambient.wav gets repetitive
   Solution: Ship with 5-10 ambient files, randomize or let user choose
   Structure: asset/ambient_*.wav (ambient_rain, ambient_vinyl, etc.)
   Usage:
     ./lohigh input.wav output.wav --ambient=random
     ./lohigh input.wav output.wav --ambient=vinyl
   Benefit: Variety while maintaining simplicity
   Complexity: LOW - file selection logic only

4.2 VINYL CRACKLE INJECTION
   Problem: True lofi needs authentic analog warmth
   Solution: Optional vinyl crackle/tape hiss overlay
   Usage: ./lohigh input.wav output.wav --crackle=light|medium|heavy
   Implementation: Layer procedurally generated noise or pre-recorded samples
   Benefit: Authentic lofi aesthetic without external DAW
   Complexity: MEDIUM - noise generation or additional assets

4.3 SIMPLE PITCH/TEMPO ADJUSTMENT
   Problem: Lofi often uses slowed/pitched samples
   Solution: --speed=0.8 (80% speed) or --pitch=-2 (2 semitones down)
   Benefit: Classic lofi slowed-reverb effect
   Complexity: HIGH - requires rubberband or soundtouch library
   Note: May violate minimalism principle - consider carefully

4.4 SHUFFLE MODE FOR MULTI-FILE INPUT
   Problem: When mixing 3+ files, order matters creatively
   Solution: --shuffle flag for random file ordering
   Usage: ./lohigh *.wav output.wav --shuffle
   Benefit: Serendipitous creative discoveries
   Complexity: TRIVIAL - randomize input array

================================================================================
CATEGORY 5: RELIABILITY & ERROR HANDLING
================================================================================

5.1 COMPREHENSIVE INPUT VALIDATION
   Problem: Tool crashes on malformed or corrupted files
   Solution: Validate files before processing:
     - Check file exists and is readable
     - Verify WAV header integrity
     - Ensure non-zero duration
     - Check for sufficient disk space for output
   Benefit: Graceful failures with helpful error messages
   Complexity: LOW - validation functions before main processing

5.2 HELPFUL ERROR MESSAGES
   Problem: Generic errors don't guide users to solutions
   Current: "error: failed to open file"
   Better: "error: cannot open 'input.wav' - file not found
            suggestion: check the file path and try again"
   Benefit: Self-service troubleshooting, reduced support burden
   Complexity: TRIVIAL - enhance error message strings

5.3 DISK SPACE CHECKING
   Problem: Running out of disk space mid-operation corrupts output
   Solution: Pre-calculate output size, verify space available
   Benefit: Fail fast with clear error vs mysterious crash
   Complexity: LOW - statvfs() or similar system call

5.4 SAFE OVERWRITES
   Problem: Accidentally overwriting important files
   Solution:
     - Warn if output file exists
     - Add --force flag to confirm overwrite
     - Default behavior: refuse to overwrite
   Benefit: Data safety, professional behavior
   Complexity: TRIVIAL - file existence check + prompt

5.5 ATOMIC FILE WRITING
   Problem: Crashes during write leave corrupt partial files
   Solution: Write to temporary file, rename on success
   Pattern: output.wav.tmp -> output.wav (atomic rename)
   Benefit: All-or-nothing writes, no corruption
   Complexity: LOW - standard file handling pattern

================================================================================
CATEGORY 6: DEVELOPER EXPERIENCE & MAINTAINABILITY
================================================================================

6.1 UNIT TEST SUITE
   Problem: No automated testing means regression risks
   Solution: Add tests/ directory with:
     - test_combine.cpp (core function tests)
     - test_edge_cases.cpp (empty files, huge files, etc.)
     - test_formats.cpp (different WAV variants)
   Framework: Catch2 (header-only, minimal) or doctest
   Benefit: Confidence in changes, catch bugs early
   Complexity: MEDIUM - requires test infrastructure setup

6.2 CONTINUOUS INTEGRATION
   Problem: Manual testing on every commit is tedious
   Solution: GitHub Actions workflow:
     - Build on push/PR
     - Run test suite
     - Test on multiple Ubuntu versions
     - Generate build artifacts
   Benefit: Automated quality assurance
   Complexity: LOW - standard GitHub Actions YAML

6.3 MEMORY SAFETY CHECKS
   Problem: C++ memory leaks or buffer overflows possible
   Solution:
     - Add valgrind checks to CI
     - AddressSanitizer builds
     - Static analysis (cppcheck, clang-tidy)
   Benefit: Production-grade reliability
   Complexity: MEDIUM - requires CI integration

6.4 BENCHMARKING SUITE
   Problem: Performance regressions unknown
   Solution: Benchmark mixing various file sizes:
     - Small (1MB), Medium (10MB), Large (100MB)
     - Track processing time, memory usage
   Tools: Google Benchmark or manual timing
   Benefit: Optimize for professional use cases
   Complexity: MEDIUM - infrastructure + reporting

6.5 DEBUG BUILD MODE
   Problem: Troubleshooting issues requires recompilation
   Solution: Makefile debug target with:
     - Debug symbols (-g)
     - No optimization (-O0)
     - Verbose logging enabled
   Usage: make debug
   Benefit: Easier troubleshooting for users and contributors
   Complexity: TRIVIAL - Makefile target addition

================================================================================
CATEGORY 7: DISTRIBUTION & ACCESSIBILITY
================================================================================

7.1 PACKAGE DISTRIBUTION
   Problem: Manual git clone + compile is barrier to entry
   Solution: Pre-built packages:
     - .deb for Debian/Ubuntu (apt install lohigh)
     - .rpm for Fedora/RHEL (dnf install lohigh)
     - AUR package for Arch Linux
     - Homebrew formula for macOS
   Benefit: Installation for non-developers, wider adoption
   Complexity: MEDIUM - packaging infrastructure per platform

7.2 STATIC BINARY RELEASES
   Problem: Users without compilers can't use tool
   Solution: GitHub Releases with static-linked binaries
     - Linux x86_64, ARM64
     - macOS x86_64, ARM64 (M1/M2)
   Build: Use musl libc for true static linking
   Benefit: Download-and-run simplicity
   Complexity: MEDIUM - cross-compilation setup

7.3 DOCKER CONTAINER
   Problem: Dependency conflicts on some systems
   Solution: Official Docker image:
     docker run -v $(pwd):/audio lohigh input.wav output.wav
   Base: Alpine Linux (minimal size)
   Benefit: Universal compatibility, no installation
   Complexity: LOW - simple Dockerfile

7.4 WEB ASSEMBLY VERSION
   Problem: CLI tools exclude non-technical users
   Solution: Compile to WASM, create web interface
   Features: Drag-drop files, click to mix, download result
   Deployment: GitHub Pages static site
   Benefit: Zero-install browser-based tool
   Complexity: HIGH - requires web frontend development
   Note: May conflict with minimalism philosophy - consider carefully

================================================================================
CATEGORY 8: DOCUMENTATION & COMMUNITY
================================================================================

8.1 COMPREHENSIVE MAN PAGE
   Problem: --help flag is good but limited
   Solution: Full man page (man lohigh)
   Sections: Synopsis, Description, Options, Examples, Files, See Also
   Installation: make install copies to /usr/share/man/man1/
   Benefit: Professional Unix tool integration
   Complexity: LOW - standard troff documentation format

8.2 EXAMPLES DIRECTORY
   Problem: Users learn best from real examples
   Solution: examples/ directory with:
     - sample_input.wav (small test file)
     - sample_output.wav (expected result)
     - creative_examples.md (use case demonstrations)
   Benefit: Lower learning curve, showcase capabilities
   Complexity: TRIVIAL - documentation and sample files

8.3 TROUBLESHOOTING GUIDE
   Problem: Common issues require maintainer support
   Solution: TROUBLESHOOTING.md covering:
     - "libsndfile not found" -> installation steps
     - "Permission denied" -> file permissions
     - "Sample rate mismatch" -> conversion advice
   Benefit: Self-service support, reduced issues
   Complexity: TRIVIAL - documentation

8.4 CONTRIBUTING GUIDELINES
   Problem: Potential contributors don't know how to help
   Solution: CONTRIBUTING.md with:
     - Code style guide (follow existing conventions)
     - How to build and test
     - Pull request process
     - Philosophy alignment notes
   Benefit: Quality contributions, community growth
   Complexity: TRIVIAL - documentation

8.5 AUDIO COMPATIBILITY MATRIX
   Problem: Users unsure what files will work
   Solution: Table in README or docs:
     | Format | Sample Rate | Bit Depth | Channels | Status |
     |--------|-------------|-----------|----------|--------|
     | WAV    | Any         | 16/24/32  | 1-2      | ✓      |
     | FLAC   | Any         | 16/24     | 1-2      | ✓      |
   Benefit: Clear expectations, reduced trial-and-error
   Complexity: TRIVIAL - documentation

8.6 CHANGELOG
   Problem: Users don't know what changed between versions
   Solution: CHANGELOG.md following Keep a Changelog format
   Sections: Added, Changed, Deprecated, Removed, Fixed, Security
   Benefit: Transparent development, upgrade planning
   Complexity: TRIVIAL - maintained with each release

================================================================================
CATEGORY 9: ADVANCED FEATURES (POWER USER FOCUSED)
================================================================================

9.1 STDIN/STDOUT SUPPORT
   Problem: Can't integrate with Unix pipelines
   Solution: Accept - for stdin/stdout:
     cat input.wav | ./lohigh - - > output.wav
     ./lohigh - - < input.wav > output.wav
   Benefit: Composability with other tools (ffmpeg, sox, etc.)
   Complexity: LOW - file descriptor handling

9.2 CONFIGURATION FILE
   Problem: Repeating same flags is tedious
   Solution: ~/.lohighrc or .lohigh.conf with defaults:
     ambient=vinyl
     fade=1.5s
     level=0.85
   Priority: CLI flags > config file > built-in defaults
   Benefit: Personalized workflows
   Complexity: LOW - simple INI or YAML parser

9.3 METADATA PRESERVATION
   Problem: Mixing strips artist/title/album tags
   Solution: Preserve ID3/Vorbis comments from first file
   Options: --metadata=first|second|merge|strip
   Benefit: Organized music libraries
   Complexity: MEDIUM - tag reading/writing libraries

9.4 LOGGING SYSTEM
   Problem: Debugging issues requires code changes
   Solution: Structured logging with levels:
     DEBUG, INFO, WARNING, ERROR
   Output: stderr (console) or --log-file=path
   Control: --log-level=debug
   Benefit: Production debugging without recompilation
   Complexity: LOW - logging framework or simple macros

9.5 PERFORMANCE PROFILING MODE
   Problem: Unknown where time is spent on large files
   Solution: --profile flag showing breakdown:
     Reading input1: 1.2s
     Reading input2: 0.8s
     Mixing: 0.3s
     Writing output: 2.1s
     Total: 4.4s
   Benefit: Optimization targets identified
   Complexity: LOW - simple timing around operations

================================================================================
CATEGORY 10: SAFETY & SECURITY
================================================================================

10.1 INPUT SIZE LIMITS
   Problem: Malicious huge files could exhaust memory/disk
   Solution: Configurable max file size (default: 1GB)
   Override: --max-size=2G (if needed for legitimate use)
   Benefit: DOS attack prevention
   Complexity: TRIVIAL - size check before loading

10.2 RESOURCE LIMITS
   Problem: Unbounded memory usage on huge files
   Solution: Process in chunks rather than loading entire files
   Chunk size: 4MB buffers (configurable)
   Benefit: Constant memory usage regardless of file size
   Complexity: MEDIUM - refactor to streaming architecture

10.3 PATH TRAVERSAL PROTECTION
   Problem: Malicious paths could write outside intended directory
   Solution: Canonicalize and validate output paths
   Block: ../, absolute paths (unless --allow-absolute)
   Benefit: Prevents security issues in scripted environments
   Complexity: LOW - path validation functions

================================================================================
CATEGORY 11: INTEGRATION & ECOSYSTEM
================================================================================

11.1 PLUGIN SYSTEM (FUTURE)
   Problem: Users want custom effects without forking
   Solution: Shared library (.so) plugin interface
   Location: ~/.lohigh/plugins/ or /usr/lib/lohigh/
   API: ProcessAudio(samples, length, sampleRate)
   Benefit: Extensibility without core bloat
   Complexity: HIGH - requires stable C API design
   Note: Major architectural change - consider v2.0

11.2 JSON OUTPUT MODE
   Problem: Hard to parse output for scripts/GUIs
   Solution: --json flag for machine-readable output:
     {
       "status": "success",
       "input_files": ["a.wav", "b.wav"],
       "output_file": "out.wav",
       "duration": 45.2,
       "size_bytes": 7891234
     }
   Benefit: Integration with larger toolchains
   Complexity: LOW - JSON formatting library (or manual)

11.3 LIBRARY MODE (liblohigh.so)
   Problem: Other applications can't use mixing logic
   Solution: Compile as shared library with C API
   Header: lohigh.h
   Usage: Link against liblohigh for programmatic access
   Benefit: Embedding in DAWs, web apps, etc.
   Complexity: MEDIUM - API design + build system changes

11.4 LANGUAGE BINDINGS
   Problem: Non-C++ developers can't use library
   Solution: Bindings for popular languages:
     - Python (ctypes or pybind11)
     - Node.js (N-API)
     - Rust (FFI)
   Benefit: Broader ecosystem integration
   Complexity: HIGH - requires multi-language expertise

================================================================================
CATEGORY 12: CREATIVE WORKFLOW ENHANCEMENTS
================================================================================

12.1 PLAYLIST MODE
   Problem: Creating long mixes from many files is tedious
   Solution: Accept .m3u or text file list:
     ./lohigh --playlist=myfiles.m3u output.wav
   Format: One file path per line
   Benefit: Complex mixes from simple text files
   Complexity: LOW - file parsing + sequential mixing

12.2 LOOPING/REPETITION
   Problem: Short ambient files need extension
   Solution: --loop=N flag repeats ambient file N times
   Example: ./lohigh input.wav output.wav --loop=3
   Result: input + (ambient × 3)
   Benefit: Padding content with repetition
   Complexity: TRIVIAL - repeat read loop

12.3 INTERLEAVE MODE
   Problem: Alternating files creates interesting patterns
   Solution: --interleave flag alternates chunks from inputs
   Example: A-chunk, B-chunk, A-chunk, B-chunk...
   Chunk size: --interleave-duration=5s
   Benefit: Creative mixing patterns
   Complexity: MEDIUM - alternating read logic

12.4 DYNAMIC RANGE COMPRESSION
   Problem: Lofi needs consistent dynamics
   Solution: --compress flag for simple compression
   Settings: Light/medium/heavy presets
   Benefit: Professional lofi "glue" without external tools
   Complexity: HIGH - DSP implementation required
   Note: May exceed minimalism scope

================================================================================
PRIORITY RANKING FOR IMPLEMENTATION
================================================================================

IMMEDIATE VALUE (Do First):
1. Crossfade support (1.1) - eliminates clicks, professional output
2. Volume normalization (1.2) - consistent levels critical
3. Batch processing (3.1) - huge workflow improvement
4. Input validation (5.1) - prevents crashes and confusion
5. Better error messages (5.2) - reduces support burden
6. Safe overwrites (5.4) - prevents data loss

SHORT TERM (High Impact):
7. Progress indicators (3.3) - UX improvement for large files
8. Reverse mode (3.2) - trivial to add, creative value
9. Sample rate conversion (1.3) - compatibility enhancement
10. Multi-format input (2.1) - works with real-world files
11. Verbose/quiet modes (3.6) - scriptability
12. Unit tests (6.1) - quality assurance foundation

MEDIUM TERM (Quality & Distribution):
13. CI/CD pipeline (6.2) - automated quality
14. Package distribution (7.1) - accessibility
15. Man page (8.1) - professional documentation
16. Examples directory (8.2) - learning resources
17. Preview mode (3.4) - experimentation workflow
18. Atomic writes (5.5) - reliability

LONG TERM (Advanced Features):
19. Multi-ambient library (4.1) - variety
20. Stdin/stdout support (9.1) - Unix philosophy
21. Configuration file (9.2) - power user workflows
22. Static binaries (7.2) - easy distribution
23. Vinyl crackle (4.2) - authentic lofi aesthetic
24. Streaming architecture (10.2) - memory efficiency

FUTURE CONSIDERATION (Major Changes):
25. Docker container (7.3) - containerization trend
26. Library mode (11.3) - ecosystem integration
27. Plugin system (11.1) - extensibility
28. WASM version (7.4) - web accessibility
29. Pitch/tempo adjustment (4.3) - complex DSP

================================================================================
IMPLEMENTATION PHILOSOPHY GUIDELINES
================================================================================

When implementing these features, maintain alignment with lohigh's core values:

✓ DO:
  - Keep single-file architecture as long as reasonable (<500 lines)
  - Maintain playful DJ Sacabambaspis personality in messages
  - Default to sensible behaviors (no configuration required)
  - Add features as opt-in flags, not required complexity
  - Write clear, readable C++ code (not clever/obscure)
  - Test with real-world audio files (music, podcasts, field recordings)
  - Document with examples, not just technical specs

✗ DON'T:
  - Add GUI or TUI interfaces (stay CLI-focused)
  - Require configuration files for basic operation
  - Introduce heavyweight frameworks or massive dependencies
  - Create artificial limitations (file size caps too low)
  - Over-engineer for hypothetical future requirements
  - Lose the fun, personality-driven user experience
  - Compete with full-featured DAWs (stay focused)

================================================================================
ARCHITECTURAL CONSIDERATIONS
================================================================================

Current Architecture:
- Monolithic: Single main.cpp file (97 lines)
- Synchronous: Blocking file I/O
- Memory: Load entire files into buffers
- Error handling: Basic error messages

Scalable Architecture (for growth):
- Modular: Split into audio.cpp, cli.cpp, effects.cpp, main.cpp
- Async I/O: Non-blocking for large files (optional)
- Streaming: Process in chunks for memory efficiency
- Error handling: Exception-based with detailed context

Recommended Transition Path:
1. Stay monolithic until ~300 lines (several features fit)
2. Split into modules at ~500 lines (natural boundaries emerge)
3. Add streaming if memory issues reported by users
4. Keep async I/O only if parallel mixing requested

================================================================================
ECOSYSTEM INTEGRATION OPPORTUNITIES
================================================================================

Potential Integrations:
- ffmpeg: Use as preprocessor for format conversion
- sox: Interop for effects not built into lohigh
- audacity: Export projects, process with lohigh, re-import
- OBS Studio: Real-time audio source via JACK
- Music players: Generate lofi versions on-the-fly
- Podcast workflows: Add ambient beds to voice recordings

Community Building:
- Subreddit: r/lohigh for user creations
- Discord: Real-time support and feature discussions
- YouTube: Tutorial videos showing creative workflows
- SoundCloud: Showcase tracks made with lohigh
- GitHub Discussions: Feature requests and Q&A

================================================================================
MONETIZATION & SUSTAINABILITY (OPTIONAL)
================================================================================

Current: GitHub Sponsors (FUNDING.yaml)

Additional Options (if desired):
- Patreon: Recurring support for development
- Commercial license: Paid support for businesses
- Premium ambient packs: Curated sound libraries
- Training/workshops: Teaching lofi production workflows
- Consulting: Custom development for specific needs

Note: Keep core tool 100% free and open source regardless of monetization.

================================================================================
FINAL RECOMMENDATIONS
================================================================================

Start with these 5 features for immediate practitioner value:

1. **Crossfade** (1.1): Eliminates clicks, professional sound
2. **Batch processing** (3.1): Process entire libraries efficiently
3. **Multi-format input** (2.1): Accept MP3/FLAC without conversion
4. **Volume normalization** (1.2): Consistent output levels
5. **Better error messages** (5.2): Self-service troubleshooting

These 5 features:
- Stay true to minimalist philosophy
- Require moderate development effort (1-2 weeks total)
- Deliver massive usability improvements
- Enable professional/industry workflows
- Maintain the fun, simple, focused nature of lohigh

The project has tremendous potential to become the go-to tool for quick lofi
mixing while preserving its unique personality and minimalist elegance.

================================================================================
EOF - DJ Sacabambaspis approves these suggestions
================================================================================
